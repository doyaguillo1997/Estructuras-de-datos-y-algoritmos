/*
Version 0.0.0.3
Jose Doyague Hernandez
*/

#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <string.h>
#include <errno.h>

typedef struct datos{
  char  *imagen;
}dato;

typedef struct nodo{
  struct nodo *nodo_siguiente;
  dato nombre;
  struct nodo *nodo_anterior;
} nodo;

nodo* insertaFinal(nodo *nuevoNodo, nodo *ptrFinal,nodo *ptrCabecera);//inserta al final
nodo* borrar(nodo *nuevoNodo, nodo *ptrFinal ,nodo *ptrCabecera, nodo *ptrSiguiente);// borra el elemento actual de la lista
void mostrarLista(nodo *ptrCabecera, nodo *ptrFinal);// muestra la lista
void visualiza(datos fotografia); //visualiza el campo nombre del nodo
void siguiente(nodo *ptrSiguiente, nodo *ptrCabecera, nodo *ptrFinal);
void anterior(nodo *ptrCabecera, nodo *ptrFinal);

void error(const char *s);
void procesoArchivo(char *archivo);


/*MAIN*/
int main(int argc, char const *argv[]) {
  //leemos datos de un fichero y los metemos en una lista
  FILE *fichero;
  dato fotografia;
  nodo *ptrCabecera, *ptrFinal, *ptrSiguiente;
  ptrCabecera = NULL;
  ptrFinal = NULL;
  int menu;

DIR *dir;
struct dirent *ent;
/*si vamos a guardar las imagenes en una carpeta llamada imagenes:*/
dir=opendir("./imagenes");
if (dir == NULL){
  error("No se pudo abrir el directorio");
}
while ((ent = readdir (dir)) != NULL) {
    /* Nos devolverÃ¡ el directorio actual (.) y el anterior (..), como hace ls */
    if ( (strcmp(ent->d_name, ".")!=0) && (strcmp(ent->d_name, "..")!=0) )
        fotografia.imagen=ent->d_name;
  {
       //fotografia.imagen=ent->d_name;
  
    nodo *nuevoNodo;
    nuevoNodo = (nodo *)malloc(sizeof(nodo));//reservamos espacio para el nuevo nodo
    nuevoNodo->nombre = fotografia;// guardamos la estructura en el nodo
    nuevoNodo->nodo_anterior = NULL; // el puntero que apunta al siguiente nodo lo ponemos a null
    nuevoNodo->nodo_siguiente = NULL;
    nodo *ptrSiguiente = ptrCabecera;

    if (ptrCabecera == NULL){//si no hay mas nodos lo metemos detras detras de la cabecera
        ptrCabecera = nuevoNodo;
    }
   ptrFinal = insertaFinal(nuevoNodo, ptrFinal, ptrCabecera);//inserta final cambia los punteros de final e inicio para que se coloquen al final.
  }
  }
closedir (dir);
 /*----------FIN----LISTA---------*/
  fflush(stdin);
  do {
    printf("0. Salir.\n ");
    printf("1. Avanzar: muestra la siguiente imagen.\n ");
    printf("2. Retroceder: muestra la imagen anterior.\n ");
    printf("3. Borrar: elimina la imagen que se este mostrando actualmente y visualiza el nombre de la imagen siguiente.\n ");
    printf("4. Limpiar: elimina todas las imagenes de la lista.\n");
    printf("5. Cargar: carga la lista doblemente enlazada circular con las imagenes almacenadas en el directorio que se indique.\n");
    printf("Elija una opcion: \n");
    scanf("%d", &menu);
    fflush(stdin);

      switch (menu) {
        case 1:
              mostrarLista(ptrCabecera, ptrFinal);
              break;
        case 2:

              break;
        case 3:

              break;
        case 4:
              
              break;
        case 5:
              
              break;
        default:
            printf("El valor introducido no es valido.");
            printf("Por favor introduzca un valor de los del menu.");

              break;
      }

  } while(menu < 5);
  return 0;
}//MAIN

void mostrarLista(nodo *ptrCabecera, nodo *ptrFinal){//muestra la lista
    if(ptrCabecera == NULL){// excepcion
        printf("\n========================\n Fichero de datos vacio\n========================\n");
    }
    else{
        nodo *ptrSiguiente = ptrCabecera;
        while((ptrSiguiente != NULL)|| (ptrSiguiente != ptrFinal)){//bucle infinito?? por que??
            visualiza(ptrSiguiente->nombre);
            ptrSiguiente = ptrSiguiente->nodo_siguiente;
        }
    }
}

void visualiza(datos fotografias){
    printf("\nNombre fotos: %s", fotografias.imagen);
}

nodo* insertaFinal(nodo *nuevoNodo, nodo *ptrFinal,nodo *ptrCabecera){//inserta al final
  if(ptrFinal == NULL){
    return nuevoNodo;
  }
  else{
    ptrFinal->nodo_siguiente = nuevoNodo;
    nuevoNodo -> nodo_anterior = ptrFinal;
    nuevoNodo ->nodo_siguiente = ptrCabecera;
    ptrCabecera -> nodo_anterior = nuevoNodo;
    ptrFinal = nuevoNodo;
    return nuevoNodo;// devolvemos nuevo nodo en lugar de un puntero doble
  }
}

void siguiente(nodo *ptrSiguiente, nodo *ptrCabecera, nodo *ptrFinal){// avanza al siguiente elemento de la lista y lo muestra por pantalla
    if(ptrCabecera == NULL){// excepcion
        printf("\n========================\n Fichero de datos vacio\n========================\n");
    }
    else{
        ptrSiguiente=ptrSiguiente->nodo_siguiente;
        visualiza(ptrSiguiente->nombre);
        }
      }
void anterior(nodo *ptrCabecera, nodo *ptrFinal){// retrocede al anterior elemento de la lista y lo muestra

    if(ptrCabecera == NULL){// excepcion
        printf("\n========================\n Fichero de datos vacio\n========================\n");
    }
    else{
        nodo *ptrAnterior = ptrCabecera;
        ptrAnterior = ptrAnterior->nodo_anterior;
        visualiza(ptrAnterior->nombre);//muestra un solo elemento de la lista
        }
      }

nodo* borrar(nodo *nuevoNodo, nodo *ptrFinal ,nodo *ptrCabecera, nodo *ptrSiguiente){
  if(ptrCabecera == NULL || ptrFinal == NULL){
      printf("Cola vacia no se puede eliminar nada!!!!!!!!!!");
  }else if(ptrSiguiente->nodo_anterior == ptrFinal){
    ptrSiguiente -> nodo_siguiente->nodo_anterior = ptrFinal;
    ptrFinal -> nodo_siguiente = ptrSiguiente -> nodo_siguiente -> nodo_anterior;
    ptrCabecera = ptrFinal-> nodo_siguiente;
    free(ptrSiguiente);
  }else if(ptrSiguiente -> nodo_siguiente == ptrCabecera){
    ptrSiguiente -> nodo_anterior -> nodo_siguiente = ptrCabecera;
    ptrFinal = ptrSiguiente -> nodo_anterior;
    ptrCabecera -> nodo_anterior = ptrSiguiente -> nodo_anterior -> nodo_siguiente;
    free(nuevoNodo);
  }else if(ptrSiguiente -> nodo_siguiente == ptrSiguiente -> nodo_anterior ){
    free(nuevoNodo);
    printf("Cola vacia!!");
  }else if(ptrSiguiente -> nodo_anterior == ptrCabecera && ptrSiguiente -> nodo_anterior -> nodo_siguiente == ptrFinal){
      ptrCabecera = ptrSiguiente -> nodo_anterior;
      ptrFinal = ptrSiguiente ->nodo_siguiente;
  }else{
    ptrSiguiente -> nodo_anterior -> nodo_siguiente = ptrSiguiente -> nodo_siguiente;
    ptrSiguiente -> nodo_siguiente ->nodo_anterior = ptrSiguiente -> nodo_anterior;
    free(ptrSiguiente);
  }
}

void eliminarTodo(nodo *nuevoNodo, nodo *ptrFinal,nodo *ptrCabecera){
  if(ptrCabecera == NULL){// excepcion
      printf("\n========================\n Fichero de datos vacio\n========================\n");
  }
  else{
      nodo *ptrSiguiente = ptrCabecera;
      while(ptrSiguiente != NULL){
          /*vamos a borrar siempre el primer nodo de la lista, y movemos el puntero siguiente hacia
            el siguiente nodo de la lista, hacemos esto hasta que el el puntero siguiente sea null
          */
          ptrSiguiente = ptrSiguiente->nodo_siguiente;
      }
    }
  }

  void error(const char *s)
  {
    perror (s);
    exit(EXIT_FAILURE);
  }
